<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Getting to know React</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<section>
				<h1>Getting to know React</h1>
				<p>
					<small>
							<a href="http://mauricio.github.io/">Maur√≠cio Linhares</a> /
							<a href="http://twitter.com/mauriciojr">@mauriciojr</a> /
							<span style="text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;">Technical Lead at DigitalOcean</span>
						</small>
				</p>
			</section>

			<section>
				<h1>This is a <em>no question left behind</em> workshop</h1>
				<p>
					If you get stuck at any point or are having trouble
					with anything that is presented, ASK. Don't wait until
					the end, stop me at any point and ask.	
				</p>
			</section>

			<section>
				<h1>React is great</h1>
				<p>
					I mean, really, even someone that's not in love with 
					JavaScript like me enjoys it.
				</p>
			</section>

			<section>
				<h1>Why?</h1>
			</section>

			<section>
				<h1>It's complicated</h1>
				<p>Front end applications are growing and including more and more JavaScript</p>
			</section>

			<section>
				<h1>jQuery doesn't cut it anymore</h1>
				<p>
					Making all your UI changes using jQuery or direct DOM manipulation is painful, hard to test and compose.
				</p>
			</section>

			<section>
				<h1>Still, why React and not others?</h1>
			</section>

			<section>
				<h1>Less opinions</h1>
				<p>React is an UI frameworks, everything else comes from other libraries and frameworks that you decide to use.
				</p>
			</section>

			<section>
				<h1>Fast</h1>
				<p>Only components that had a state change will be re-rendered, everything else stays the same.
				</p>
			</section>

			<section>
				<h1>(Mostly) plain JavaScript</h1>
				<p>
					There aren't special objects or flows you need to follow, everything is a JS object and you can build them any way you'd
					like.
				</p>
			</section>

			<section>
				<h1>Still, YMMV</h1>
				<p>
					There's no such thing as the perfect framework, give the others a try and figure out what works best for you and your needs.
				</p>
			</section>

			<section>
				<h1>What do you need to get started?</h1>
				<p>
					Latest nodejs install (currently 6.7.0)
				</p>
			</section>

			<section>
				<h1>After installing node, in a command line:</h1>
				<pre>
					<code data-trim class="shell">
$ npm install -g create-react-app
$ create-react-app libertyjs-todo
					</code>
				</pre>
			</section>

			<section>
				<h1>Do I <strong>have</strong> to use Nodejs?</h1>
				<p>
					Yes, but only for development, you can produce a standalone build and integrate it to your app or favorite framework.
				</p>
			</section>

			<section>
				<h1>Let's walk over the files we have</h1>
				<p>
					<ul>
						<li>App.js</li>
						<li>index.js</li>
						<li>index.html</li>
					</ul>
				</p>
			</section>

			<section>
				<h1>Components are the heart of your React app</h1>
				<p>
					They're the main point of interaction between the user and the actions your app implements. They're a mix of controllers
					and views if you're used to MVC.
				</p>
			</section>

			<section>
				<h1>What kind of sorcery is this code?</h1>
				<p>
					To make your life easier, most React development is done using ES6 syntax and a bunch of other niceties (the JSX syntax that
					allows you to enter HTML directly into JavaScript code).
				</p>
			</section>

			<section>
				<h1>What if I don't like it?</h1>
				<p>
					You can definitely write your apps using only browser compatible JavaScript but the pain of doing so might not be worth the
					trouble.
				</p>
			</section>

			<section>
				<h1>Our first component!</h1>
				<p>TodoItem.js</p>
			</section>

			<section>
				<h1>Then we integrate it in App.js</h1>
			</section>

			<section>
				<h1>Now let's get some state in place</h1>
				<p>
					<ul>
						<li>props</li>
						<li>getInitialState</li>
						<li>state</li>
					</ul>
				</p>
			</section>

			<section>
				<h1>Props!</h1>
				<p>
					Immutable properties of your component, when they change, a new component is rendered 
					instead of reusing the existing one</p>
			</section>

			<section>
				<h1>propTypes</h1>
				<p>
					Basic type and presence validation for your props, customizable 
					to perform other types of validation.
				</p>
			</section>

			<section>
				<h1>getInitialState</h1>
				<p>
					Setup method to fill in your component with the basic state 
					it needs to be rendered for the first time. Must return an 
					object.
				</p>
			</section>

			<section>
				<h1>state</h1>
				<p>
					Actual state that your component holds, gets changed through the 
					setState method and makes a component be re-rendered.
				</p>
			</section>

			<section>
				<h1>Creating the form component</h1>
				<p>
					Now that we can show tasks, it's time to be able to add them!
				</p>
			</section>

			<section>
				<h1>Event handlers</h1>
				<p>
					All React HTML components allow you to add event handlers to them, 
					just like you would in plain HTML and JavaScript, the only difference
					is that they're included right at the component markup and handlers
					are camel cased so <em>onChange</em> instead of <em>onchange</em>.
				</p>
			</section>

			<section>
				<h1>Function name on event handler</h1>
				<pre>
					<code data-trim class="jsx">
<input
value={this.state.text}
onChange={this.handleTextChange}/>
					</code>
				</pre>
			</section>

			<section>
				<h1>No <em>()</em> on event handlers!</h1>
				<p>
					You don't want to call the function, you want to 
					provide a callback as a property so the component can call it.
				</p>
			</section>

			<section>
				<h1>But wait, where is this state going?</h1>
				<p>
					We have to bubble the task insert event up so we need a callback 
					prop at the form to notify someone else we need to insert a new task.
				</p>
			</section>

			<section>
				<h1>Creating a TodoView</h1>
				<p>
					We want to be able to show many todo lists at the same time,
					so lets create a component to do just that. But first let's 
					look at ImmutableJS.
				</p>
			</section>

			<section>
				<h1>What is it?</h1>
				<p>
					A JS library by Facebook (and used by React) that provides immutable
					collections (including List, Map and Set).
				</p>
			</section>

			<section>
				<h1>Why should you care?</h1>
				<p>
					Most of the work in a React app, as you have noticed, revolves 
					around handling state changes. Using an immutable collection library
					makes it easier to figure out if stuff has changed and what needs to be 
					updated.
				</p>
			</section>

			<section>
				<h1>Function name on event handler</h1>
				<pre>
					<code data-trim class="shell">
$ npm install immutable --save
					</code>
				</pre>
			</section>

			<section>
				<h1>Now let's build our new component!</h1>
				<p>
					There really isn't much of a difference here.
				</p>
			</section>

			<section>
				<h1>Your turn!</h1>
				<p>
					Now that we have a way to have many task lists, add a component that 
					allows us to add new tasks lists (just a text field to enter a name).
				</p>
			</section>

			<section>
				<h1>15 minutes</h1>
				<p>
					Ready. Set. Go!
				</p>
			</section>

			<section>
				<h1>Review time!</h1>
			</section>

			<section>
				<h1>What has been the main pain point here?</h1>
			</section>

			<section>
				<h1>State!</h1>
				<p>
					State management is hard, for all frameworks.
				</p>
			</section>

			<section>
				<h1>Did you notice a pattern?</h1>
				<p>
					State is pushed all the way up, to a component that doesn't really 
					to much but handles all state changes.
				</p>
			</section>

			<section>
				<h1>Application state lives out of components</h1>
				<p>
					It doesn't make much sense to couple them together since
					the views are basically just rendering data.
				</p>
			</section>

			<section>
				<h1>The flux model</h1>
				<p>
					<img src="images/flux-simple-f8-diagram-with-client-action-1300w.png"/>
				</p>
			</section>

			<section>
				<h1>Actions</h1>
				<p>
					Cause events to be fired to the dispatcher, interested parties
					register at the dispatcher to wait for events and perform operations
					in response to them.
				</p>
			</section>

			<section>
				<h1>Dispatcher</h1>
				<p>
					Collects all events that have been fired and delivers them to interested
					parties, the app's event bus. There's only one dispatcher per app 
					most of the time.
				</p>
			</section>

			<section>
				<h1>Stores</h1>
				<p>
					State! State everywhere! State finally get's it's own place without any
					view or react related code (mostly), stores will be listening on the 
					dispacher for events that will cause them to change, actions do not
					write directly to stores or talk to them.
				</p>
			</section>

			<section>
				<h1>Views/Controllers</h1>
				<p>
					This is what we have been doing already, views call actions and access
					stores to show the data, they don't talk to the dispatcher.
				</p>
			</section>

			<section>
				<h1>Check the arrows!</h1>
				<p>
					<img src="images/flux-simple-f8-diagram-with-client-action-1300w.png"/>
				</p>
			</section>

			<section>
				<h1>Flux is a model</h1>
				<p>
					You're not required to build your React app using Flux, if your needs 
					are simple, just rolling out your own might suffice.
				</p>
			</section>

			<section>
				<h1>There is no True Flux</h1>
				<p>
					There are many implementations of Flux and Flux-like frameworks for React,
					pick whatever works for you (Redux and Nuclearjs are two of the big ones).
				</p>
			</section>

			<section>
				<h1>Let's introduce Flux to our app</h1>
				<p>
					It's not as hard as you're thinking.
				</p>
			</section>

			<section>
				<h1>Install nuclear-js</h1>
				<pre>
					<code data-trim class="shell">
$ npm install --save nuclear-js
					</code>
				</pre>
			</section>

			<section>
				<h1>It all starts with the reactor</h1>
				<pre>
					<code data-trim class="javascript">
import { Reactor } from 'nuclear-js';

const reactor = new Reactor({
  debug: true
});

export default reactor;						
					</code>
				</pre>
			</section>

			<section>
				<h1>First, define actions</h1>
				<p>
					<ul>
						<li>Add a new todo list</li>
						<li>Add a new task in a todo list</li>
					</ul>
				</p>
			</section>

			<section>
				<h1>Let's setup the action names - actionTypes.js</h1>
				<pre>
					<code data-trim class="javascript">
import keyMirror from 'fbjs/lib/keyMirror';

export default keyMirror({
  ADD_TODO: null,
  ADD_TODO_LIST: null
});
					</code>
				</pre>
			</section>

			<section>
				<h1>And the actions</h1>
				<pre>
					<code data-trim class="javascript">
import reactor from "./reactor.js";
import Immutable from "immutable";
import ActionTypes from "./actionTypes.js";
import Keys from "./Keys.js";

export default {
    addTodoList(name) {
        var list = {
            Keys.Properties.TodoList.TITLE: name            
        };

        reactor.dispatch(ActionTypes.ADD_TODO_LIST, 
			Immutable.fromJS(list));        
    }
}
					</code>
				</pre>
			</section>

			<section>
				<h1>What happens in actions?</h1>
				<p>
					<ul>
						<li>Prepare and send events to dispacher</li>
						<li>Perform network requests</li>
						<li>Anything that could change state</li>
					</ul>
				</p>
			</section>

			<section>
				<h1>And now the store</h1>
				<pre>
					<code data-trim class="javascript">
function addTodoList(state, event) {
    return state.set(
        event.get(Keys.Properties.TodoList.TITLE),
        Immutable.List()
    );
}

export default Store({
    getInitialState() {
        return Immutable.Map();
    },

    initialize() {
        this.on(ADD_TODO_LIST, addTodoList);
    }
});
					</code>
				</pre>
			</section>

			<section>
				<h1>What happens in stores?</h1>
				<p>
					State change alone. Stores shouldn't really do anything
					other than updating it's own state.					
				</p>
			</section>

			<section>
				<h1>Connect reactor and stores - App.js</h1>
				<pre>
					<code data-trim class="javascript">
import reactor from "./reactor.js";
import TodoStore from "./TodoStore.js";

reactor.registerStores({
  'todos': TodoStore
})
					</code>
				</pre>
			</section>

			<section>
				<h1>Setup getters - getters.js</h1>
				<pre>
					<code data-trim class="javascript">
export default { 
    todos: ["todos"]
 };
					</code>
				</pre>
			</section>

			<section>
				<h1>Wait, what is a getter?</h1>
				<p>
					Expressions that are evaluated to pull data from stores.
					Components to not access stores directly, they evaluate getters
					to access the data. Use getters to transform the data or filter
					so that you don't have to do it on components.
				</p>
			</section>			

			<section>
				<h1>Hook it up to your component - App.js</h1>
				<pre>
					<code data-trim class="javascript">
import getters from "./getters.js";

const App = React.createClass({
  mixins: [reactor.ReactMixin],

  getDataBindings() {
    return {
      todos: getters.todos
    }
  }
}
					</code>
				</pre>
			</section>	

			<section>
				<h1>Call the actions! - App.js</h1>
				<pre>
					<code data-trim class="javascript">
import Actions from "./actions.js";

updateList(name, tasks) {
	Actions.updateTodoList(name, tasks);
}

addNewList(name) {
	Actions.addTodoList(name);
}
					</code>
				</pre>
			</section>	

			<section>
				<h1>Inside render</h1>
				<pre>
					<code data-trim class="javascript">
this.state.todos
					</code>
				</pre>
			</section>

			<section>
				<h1>Props all the way now!</h1>
				<p>
					Since the state is now provided by nuclear
					we can just use props everywhere and once the 
					store gets updated all components are updated as well.
				</p>
			</section>

			<section>
				<h1>What about some HTTP?</h1>
				<p>
					A front end app is not complete until we call
					some HTTP service on the backend so let's hook it up!
				</p>
			</section>

			<section>
				<h1>Install request</h1>
				<pre>
					<code data-trim class="shell">
$ npm install --save request
					</code>
				</pre>
			</section>			

			<section>
				<h1>Include this at your package.json and restart</h1>
				<pre>
					<code data-trim class="json">
"proxy": "http://libertyjstasks.herokuapp.com",
					</code>
				</pre>
			</section>	

			<section>
				<h1>Setup the library</h1>
				<pre>
					<code data-trim class="javascript">
import request from 'request';

const baseRequest = request.defaults({
  headers: {'Accept': 'application/json'},
  json: true
});

const baseUrl = "http://localhost:3000/task_lists";
					</code>
				</pre>
			</section>

			<section>
				<h1>Let's have a list action</h1>
				<pre>
					<code data-trim class="javascript">
listTodos() {
  baseRequest.get({ url: baseUrl }, (error, response, body) => {
    if (!error && response.statusCode === 200) {
      reactor.dispatch(ActionTypes.LIST_TODO_LISTS, 
	    Immutable.fromJS(body));
    } else {
      console.log(error);
      console.log(response);
    }
  });
}
					</code>
				</pre>
			</section>

			<section>
				<h1>Here's the data format</h1>
				<pre>
					<code data-trim class="javascript">
[
   {
      "title":"Groceries",
      "tasks":[
         {
            "title":"Coconut Milk",
            "completed":false
         },
         {
            "title":"Turmeric",
            "completed":false
         }
      ]
   }
]
					</code>
				</pre>
			</section>

			<section>
				<h1>Register it at the store</h1>
				<pre>
					<code data-trim class="javascript">
function todoListsReceived(state, event) {
    return event.reduce((map, taskList) => {
        return map.set(
            taskList.get("title"), 
            taskList.get("tasks").map((task) => task.get("title")) );
    }, Immutable.Map());
}

// at the store
this.on(ActionTypes.LIST_TODO_LISTS, todoListsReceived);
					</code>
				</pre>
			</section>

			<section>
				<h1>Update the two other calls to call the service</h1>
				<p>
					They're basically doing the same stuff, just need to 
					check for errors and then decide what to do.
				</p>
			</section>

			<section>
				<h1>And that's it!</h1>
				<p>
					Since this was only an actions/store thing there
					is no reason to change the components, they stay as they are.
				</p>
			</section>

			<section>
				<h1>Do we still have time?</h1>
				<p>
					Let's play around including marking stuff as complete!
				</p>
			</section>

			<section>
				<h1>Questions?</h1>
			</section>

			<section>
				<h1>Thanks!</h1>
			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
</body>

</html>